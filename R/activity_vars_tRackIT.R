#' calculate variables for activity classification
#'
#' @description calculates variables for the ML-based activity classification
#'
#'
#' @author Jannis Gottwald
#'
#' @param animal list, list generated by initAnimal functiom
#' @param tcol string, colname of timestamp column
#' @param scol string, colname of signal strength column
#' @param dcol string, colname of signal duration column
#' @param tzone string, time zone of timestamp
#' @param rscale numeric, numericvalue to rescale to dBW scale
#'
#' @export
#'
#'


activity.vars.tRackIT<-function(animal, tcol, scol,dcol, tzone, rscale=0){
  d   <- function(x,y) abs(x-y)
  
  
  fls<-list.files(animal$path$filtered, full.names = TRUE)
  
  #create variables per filtered file
  lapply(fls, function(x){
    
    print(x)
    data<-data.table::fread(x)
    
    data<-as.data.frame(data)
    
    
    data$max_signal<-data[,scol]
    data$max_signal<-data$max_signal-rscale
    data$timestamp<-data[,tcol]
    data$receiver<-data[,dcol]
    
    data$timestamp<-gsub("T", " " ,data$timestamp)
    data$timestamp<-gsub("Z", "" ,data$timestamp)
    data$timestamp<-as.POSIXct(data$timestamp, tz=tzone)
    
    #split into five minute bins
    lst1 <- split(data, droplevels(cut(as.POSIXct(data$timestamp, 
                                                  format="%Y-%m-%d %H:%M:%S", tz=tzone),breaks = "5 min")))
    
    
    #identify receiver with highest number of data points per 5 minute bin
   # counter<-0
    
    df<-plyr::ldply(lst1, function(k){
      #print(i)
      ##print(x)
      #counter<<-counter+1
      #print(counter)
      #print(head(k))
      tmp<-k[k$receiver==tail(names(sort(table(k$receiver))), 1)[1],]
      
      
      # 5 Minutes= 300 seconds = ~300 beeps if tag with beep intervall of 1s is perfectly received. 100 entries per receiver is equivalent to ~30% reception time. Should be adapted to specs of tags- e.g. tags that have a beep intervall of 2s should at least have 50 entries.
      if(nrow(tmp)>=50){
        
        #print(">50")
        
        #identify receiver with second highest number of data points per 5 minute bin
        tmp2<-k[k$receiver==tail(names(sort(table(k$receiver))), 2)[1],]
        nrow(tmp2)/nrow(tmp)
        
        #if number of data points of second receiver is at least 80% of first receiver variables such as co-variance can be calculated
        if((nrow(tmp2)/nrow(tmp))>=0.8 & (tail(names(sort(table(k$receiver))), 2)[1]!=tail(names(sort(table(k$receiver))), 1)[1])){
          
          #print("yes")
          
          tmp$time_control1<-tmp$timestamp
          tmp2$time_control2<-tmp2$timestamp
          
          tmp2$max_signal_2<-tmp2$max_signal
          
          
          
          tmp2<-tmp2[, c("timestamp", "max_signal_2", "time_control2")]
        
          idx <- sapply( tmp$timestamp, function(x) which.min( d(x,tmp2$timestamp) )) # find matches
          
          match<-cbind(tmp,tmp2[idx,-1,drop=FALSE])
          match$timediff<-as.numeric(abs(difftime(match$time_control1, match$time_control2)))
          match<-as.data.frame(match)
          #exclude timediffs>1
          match$max_signal_2[match$timediff>1]<-NA
          match$n_receivers<-2
          
          match$time_control1<-NULL
          match$time_control2<-NULL
          match$timediff<-NULL
          return(match)}else{
            
            #print("no")
            
            tmp$max_signal_2<-NA
            
            tmp$n_receivers<-1
            
            return(tmp)
          }
        
      }
      
      
    })
    
    
    
    if(nrow(df)>100){
      
      
      
      #print("2 reveivers variables")
      df<-df[order(df$timestamp),]
      if(nrow(df[!is.na(df$max_signal_2),])>100){
        df$diff<-abs(df$max_signal-df$max_signal_2)
        df$diff_var<-RollingWindow::RollingVar(x = df$diff, window = 10, na_method = "window")
        df$diff_std<-RollingWindow::RollingStd(x = df$diff, window = 10, na_method = "window")
        df$cor_max<-RollingWindow::RollingCorr(x = df$max_signal, y=df$max_signal_2, window = 10, na_method = "window")
        df$cov_max<-RollingWindow::RollingCov(x = df$max_signal, y=df$max_signal_2, window = 10, na_method = "window")
      }else{
        df$diff<-NA
        df$diff_var<-NA
        df$diff_std<-NA
        df$cor_max<-NA
        df$cov_max<-NA
      }
      
      
      #print("1 receiver variables")
      
      #smooth data with max, mean and hampel
      
      #print("hampel")
      hampel_1<-pracma::hampel(x=df$max_signal,k = 10, t0 = 1) 
      df$hampel<-hampel_1$y
      df$max<-RollingWindow::RollingMax(x = df$max_signal, window = 10, na_method = "window")
      df$mean<-RollingWindow::RollingMean(x = df$max_signal, window = 10, na_method = "window")
      
      #calculate variables on raw signals
      df$var<-RollingWindow::RollingVar(x = df$max_signal, window = 10, na_method = "window")
      df$std<-RollingWindow::RollingStd(x = df$max_signal, window = 10, na_method = "window")
      df$kurt<-RollingWindow::RollingKurt(x = df$max_signal, window = 10, na_method = "window")
      df$skew<-RollingWindow::RollingSkew(x = df$max_signal, window = 10, na_method = "window")
      df$sumsq<-RollingWindow::RollingSS(x = df$max_signal, window = 10, na_method = "window")
      
      #calculate variables on RollingWindow::Rolling max smoothed signals
      df$var_max<-RollingWindow::RollingVar(x = df$max, window = 10, na_method = "window")
      df$std_max<-RollingWindow::RollingStd(x = df$max, window = 10, na_method = "window")
      df$kurt_max<-RollingWindow::RollingKurt(x = df$max, window = 10, na_method = "window")
      df$skew_max<-RollingWindow::RollingSkew(x = df$max, window = 10, na_method = "window")
      df$sumsq_max<-RollingWindow::RollingSS(x = df$max, window = 10, na_method = "window")
      
      #calculate variables on RollingWindow::Rolling mean smoothed signals   
      df$var_mean<-RollingWindow::RollingVar(x = df$mean, window = 10, na_method = "window")
      df$std_mean<-RollingWindow::RollingStd(x = df$mean, window = 10, na_method = "window")
      df$kurt_mean<-RollingWindow::RollingKurt(x = df$mean, window = 10, na_method = "window")
      df$skew_mean<-RollingWindow::RollingSkew(x = df$mean, window = 10, na_method = "window")
      df$sumsq_mean<-RollingWindow::RollingSS(x = df$mean, window = 10, na_method = "window")
      
      #calculate variables on hampel smoothed signals    
      df$var_hampel<-RollingWindow::RollingVar(x = df$hampel, window = 10, na_method = "window")
      df$std_hampel<-RollingWindow::RollingStd(x = df$hampel, window = 10, na_method = "window")
      df$kurt_hampel<-RollingWindow::RollingKurt(x = df$hampel, window = 10, na_method = "window")
      df$skew_hampel<-RollingWindow::RollingSkew(x = df$hampel, window = 10, na_method = "window")
      df$sumsq_hampel<-RollingWindow::RollingSS(x = df$hampel, window = 10, na_method = "window")
      
      
      #df$timestamp<-as.character(df$timestamp)
      
      
      #dir.create(paste0(animal$path$root,"/variables/"))
      data.table::fwrite(df, paste0(animal$path$vars,"/", basename(x)))
      
      
    }}
  )}


